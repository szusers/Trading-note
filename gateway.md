# 讲讲和gateway相关的一些业务

对于整个交易环节，不管是algo还是gateway都有属于自己的风控。不同组件的风控之间完全独立，只拦截自己这一part的异常或者错误指令。上下游剥离的检测逻辑确保多层风控保障交易行为

我们写代码的时候核心是保证我们代码一旦发生错误不会导致严重后果（别有错误交易，安全第一，故障为导向的安全）多理论，多时间测试，确保在任何情况下可控

## gateway组件

主要分为 风控 + 信息处理（我们使用rpc远端通信协议来进行交互）
因为本质上server和client就是通过 请求（查询）-> 返回信息这种方式进行运作的。在我们的业务中查询就是发送订单，然后client通过一个回调线程来处理server返回的信息
所以接收信息分为两步：
 - 回调线程处理数据
    - 常见交互方式：返回的数据包信息一般都是回调中处理，无需主动调用。我们需要实现的只是拿到信息后的处理逻辑
    - 我们本质上是通过函数回调接口的传参拿到数据进行处理。柜台服务器已经帮我们处理好数据了只是通过传参的方式给我们，这样做是为了确保我们能有比较高的自定义程度。所以我们可以通过虚函数重载进行我们的自定义方法
 - 返回给上游（algo和gateway的交互数据）

发单又有两种方式：
 - 裸协议：自己在应用层组包，手动发包（这里就会涉及到计算机网络的知识了）
 - 调函数传入数据

## 柜台 -> 交易所（这个对贵台服务器是无感的）
柜台服务器中又分为了前置服务器和订单服务器，前置是柜台收取订单用的。订单服务器用来周期性查看前置服务器的订单。

交易所：
撮合服务器：交易数据的数据池管理装置。里面的订单会发送给订单部。若产生了交易（即交易成功了），将会发送成功回报给柜台的前置服务器。柜台前置服务器将发送交易成功信息给gateway，然后我们再进行处理。
行情服务器：接收撮合服务器传回来的数据信息然后分析行情。它将广播所有的数据信息（它的作用是维护标的的市场状态并实时公布市场信息）


## 剩余杂问题
退单 = 撤单 买入订单之前没有成交之前是没有仓位的，那么这个时候的订单想撤就撤没有副作用。但是成交后的订单我们将无法撤销，交易所会拒绝我们的撤单申请
部分成交撤单就是指：你的订单成交了一部分，比如想买19手，成交了5手，那就还剩5手挂在哪里，这时候去撤单那么也能把剩余的5手购买请求撤销掉

回滚应该是某一种柜台的说法而已，不用太关注
订单是发出去之后就存在了，交易所拒单本质上你的这个指令有问题被拒绝了
那么它就是一个被拒绝的订单
只需要把被拒绝的信息记录下来就行，这个订单流程就结束了，我们不会去关注一个错误订单（被拒绝的）  因为对于gateway来说只是记录一下拒单日志和信息返回给上游进行解析处理就好。gateway本身不涉及使用算法处理交易数据。

挂单是行为，只要我们向交易所发出订单指令，都叫挂单
挂单成功是指，交易所受理了这个订单。收到交易所回报就是挂单成功或者失败。回报为失败的话我们发送撤单同样会被拒绝撤单（因为回报为失败，都没挂单成功又如何能撤？）
每个发出去的订单你可以申请去撒销它，但是是否能撒销成功要看这个订单目前在什么状态下
如果已经全部成交或者还没挂单成功（即没被交易所受理），那么你的撤单请求是会披拒绝的

### （交易所）拒单和（交易所）拒绝撤单分开理解：拒绝你的挂单那就是拒单。拒绝你的撤单请求，那就是拒绝撤单

### 撤单只有两种：1、我们主动申请撤单  2、订单属性导致自动撤单   总的来说，订单只有挂上队列了才有撤销这一说（很正常，因为交易所都没有回报交易成功怎么可能能撤销？？？）

大部分交易策略都对撤单时延不太敏感，撤单的性能优先级是相对较低的
